<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试指南</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/FE-Interview-Questions/logo.png">
    <link rel="manifest" href="/FE-Interview-Questions/manifest.json">
    <link rel="apple-touch-icon" href="/FE-Interview-Questions/icons/apple-touch-icon-152x152.png">
    <link rel="mask-icon" href="/FE-Interview-Questions/icons/safari-pinned-tab.svg" color="#3eaf7c">
    <meta name="description" content="web前端面试题总结，面试指南，前端面试题整理，web面试宝典，刷题神器，按模块分类整理总结，打造最全面的前端面试题">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/FE-Interview-Questions/assets/css/0.styles.fe1fc015.css" as="style"><link rel="preload" href="/FE-Interview-Questions/assets/js/app.4d3eef8b.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/5.d87f3d46.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/4.5e30d557.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/27.2e5ff387.js" as="script"><link rel="preload" href="/FE-Interview-Questions/assets/js/11.7002e677.js" as="script"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/1.0bd0f9f1.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/10.7fade74d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/100.4bb4339a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/101.3da4ab0d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/102.14eeef75.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/103.a312461c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/104.82fb58a2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/105.c6fb535b.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/106.101c868c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/107.02dee0ac.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/108.c961c174.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/109.d161f6cf.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/110.084e3625.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/111.64be6390.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/112.bc30a654.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/113.2c8dc1d2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/114.f670472d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/115.1c595b85.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/116.f39f475e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/117.d43597d0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/118.5358be3c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/119.0d49c662.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/12.705a3339.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/120.7a836cf0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/121.c17eccd9.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/122.11c3ee4d.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/123.76c7d2bc.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/124.599a565c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/125.8dc84be2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/126.bd688273.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/127.9e801fdb.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/128.83e9ddef.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/129.3403ae35.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/13.ca550be9.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/130.acfb719a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/131.03718ac9.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/132.9a3d68b0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/133.1c626751.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/134.86fc3857.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/135.fc7c4136.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/136.443e4bf6.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/137.4d6c5cf5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/138.3b7e22f6.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/139.710bd9b1.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/14.dface8e8.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/140.a6c806ab.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/141.a6e9db76.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/142.8570ff43.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/143.89a725e3.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/144.a17e9517.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/145.5560622f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/146.bbbc6c67.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/147.0bebb91e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/148.86519ba6.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/149.dcf67378.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/15.6ebe4be7.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/150.855c1a5f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/151.730e8291.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/152.497722a0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/16.db4e25b0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/17.3cb003ac.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/18.a8f37292.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/19.2f751162.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/20.9de5f179.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/21.ce738c59.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/22.9c4a5db3.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/23.c0127c7e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/24.d9e307da.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/25.9dbe54cb.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/26.a4818dda.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/28.29a789b0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/29.2e5a4a57.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/3.cb4d756e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/30.0eaf41aa.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/31.910002ba.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/32.f503bf73.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/33.db6ba3b8.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/34.c3c91192.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/35.e0c3b1b7.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/36.a66f39dd.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/37.eaee82e2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/38.95992b6a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/39.b0a6303e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/40.1df52b4a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/41.e9c37d29.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/42.959194ff.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/43.899098c9.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/44.5c09586a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/45.0e12e457.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/46.2144f8d2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/47.5dbc7ee9.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/48.291fcc1f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/49.2daac94b.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/50.0cbad7a9.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/51.c28bf51f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/52.6d36507e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/53.10119c99.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/54.db9e76e4.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/55.645cc454.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/56.b6982c9a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/57.fff3c894.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/58.5d0cba7c.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/59.0c66cef3.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/6.8f25e966.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/60.bdc0cfb6.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/61.3e604aa5.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/62.247c1f65.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/63.54ab87df.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/64.bf19ef21.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/65.f5b836b0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/66.93f981f8.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/67.863fdc38.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/68.a80c8d0f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/69.3c1e7209.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/7.69e80a21.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/70.60a4c3f1.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/71.6b71561b.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/72.d3bd7c1f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/73.fa6b606e.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/74.ffa6535f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/75.6ebd0ee0.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/76.114b5095.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/77.f3e8a180.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/78.b646bfea.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/79.32bf4315.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/8.023d8af1.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/80.ab5f75cd.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/81.5078ffd1.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/82.626fcfd6.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/83.4dd0f6a2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/84.dc6d772f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/85.82d56c4f.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/86.084ef2a7.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/87.8587fce4.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/88.2c95f3c4.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/89.dd02f1c8.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/9.d02267eb.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/90.1bc7d887.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/91.bb2039b9.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/92.3cab4adc.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/93.df37cd96.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/94.617393ad.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/95.7b02dd16.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/96.960e6728.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/97.0a0a7f5a.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/98.f451e4e2.js"><link rel="prefetch" href="/FE-Interview-Questions/assets/js/99.e2e2a0c1.js">
    <link rel="stylesheet" href="/FE-Interview-Questions/assets/css/0.styles.fe1fc015.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><div><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/FE-Interview-Questions/" class="home-link router-link-active"><img src="/FE-Interview-Questions/logo.png" alt="前端面试指南" class="logo"> <span class="site-name can-hide">前端面试指南</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="login-modal"><div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="微信扫码登录" class="el-dialog el-dialog--center" style="margin-top:15vh;width:32%;"><div class="el-dialog__header"><span class="el-dialog__title">微信扫码登录</span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><!----></div></div></div></div> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端算法面试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/FE-Interview-Questions/algorithm-interview/note/01-快速上手——从0到1掌握算法面试需要的数据结构（一）.html" class="sidebar-link">快速上手——从0到1掌握算法面试需要的数据结构（一）</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/02-快速上手——从0到1掌握算法面试需要的数据结构（二）.html" class="sidebar-link">快速上手——从0到1掌握算法面试需要的数据结构（二）</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/03-快速上手——从0到1掌握算法面试需要的数据结构（三）.html" class="sidebar-link">快速上手——从0到1掌握算法面试需要的数据结构（三）</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/04-递归初相见——二叉树递归遍历的三种姿势.html" class="sidebar-link">递归初相见——二叉树递归遍历的三种姿势</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/05-算法的衡量——轻松理解时间复杂度与空间复杂度.html" class="sidebar-link">算法的衡量——轻松理解时间复杂度与空间复杂度</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/06-数组的应用——真题归纳与解读.html" class="sidebar-link">数组的应用——真题归纳与解读</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/07-字符串的应用——真题归纳与解读.html" class="sidebar-link">字符串的应用——真题归纳与解读</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/08-链表的应用——真题归纳与解读.html" class="sidebar-link">链表的应用——真题归纳与解读</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/09-快慢指针与多指针——玩转链表复杂操作.html" class="sidebar-link">快慢指针与多指针——玩转链表复杂操作</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/10-姿势特别的链表——环形链表专题.html" class="sidebar-link">姿势特别的链表——环形链表专题</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/11-栈与队列怎么玩（上）.html" class="sidebar-link">栈与队列怎么玩（上）</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/12-栈与队列怎么玩（下）.html" class="active sidebar-link">栈与队列怎么玩（下）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/algorithm-interview/note/12-栈与队列怎么玩（下）.html#为什么一道题可以成为高频面试题" class="sidebar-link">为什么一道题可以成为高频面试题</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/algorithm-interview/note/12-栈与队列怎么玩（下）.html#如何用栈实现一个队列" class="sidebar-link">如何用栈实现一个队列？</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/algorithm-interview/note/12-栈与队列怎么玩（下）.html#认识双端队列" class="sidebar-link">认识双端队列</a></li><li class="sidebar-sub-header"><a href="/FE-Interview-Questions/algorithm-interview/note/12-栈与队列怎么玩（下）.html#滑动窗口问题" class="sidebar-link">滑动窗口问题</a></li></ul></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/13-遍历专题 DFS 与 BFS.html" class="sidebar-link">遍历专题 DFS 与 BFS</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/14-场景化解读 递归与回溯思想在真题中的应用.html" class="sidebar-link">场景化解读 递归与回溯思想在真题中的应用</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/15-二叉树真题归纳与解读.html" class="sidebar-link">二叉树真题归纳与解读</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/16-特殊的二叉树——二叉搜索树专题.html" class="sidebar-link">特殊的二叉树——二叉搜索树专题</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/17-特殊的二叉树——平衡二叉树专题.html" class="sidebar-link">特殊的二叉树——平衡二叉树专题</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/18-特殊的二叉树——堆结构及其在排序中的应用.html" class="sidebar-link">特殊的二叉树——堆结构及其在排序中的应用</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/19-排序算法专题（上）.html" class="sidebar-link">排序算法专题（上）</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/20-排序算法专题（下）.html" class="sidebar-link">排序算法专题（下）</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/21-普通人也能吃透的动态规划思想专题（上）.html" class="sidebar-link">普通人也能吃透的动态规划思想专题（上）</a></li><li><a href="/FE-Interview-Questions/algorithm-interview/note/22-普通人也能吃透的动态规划思想专题（下）.html" class="sidebar-link">普通人也能吃透的动态规划思想专题（下）</a></li></ul></section></li></ul> </aside> <main class="page"> <div id="container" class="theme-default-content lock"><div class="content__default"><p>结束了针对栈结构的定点轰炸，我们现在开始要缓缓过渡到队列的世界了。</p> <p>关于队列，在算法面试中大家需要掌握以下重点：</p> <ul><li>栈向队列的转化</li> <li>双端队列</li> <li>优先队列</li></ul> <blockquote><p>以上考点中，1 属于基础难度， 2 对一部分同学来说已经有点吃力，3 的区分度最高——优先队列属于高级数据结构，其本质是二叉堆结构，考虑到相关题目具有较强的综合性，我们把它放在小册二叉树和堆相关的专题来展开。在本节，我们集中火力向前两个命题点开炮。</p></blockquote> <h2 id="为什么一道题可以成为高频面试题"><a href="#为什么一道题可以成为高频面试题" class="header-anchor">#</a> 为什么一道题可以成为高频面试题</h2> <p>如何用栈实现队列？这个问题在近几年的算法面试中热度非常高。</p> <p>所谓“热度”从何而来？这里就引出了一个非常有趣的话题：（在前端算法面试中）什么样的题目是好题？</p> <p>首先，不能剑走偏锋：好的面试题，它考察的大多是算法/数据结构中最经典、最关键的一部分内容，这样才能体现公平；其次，它的知识点要尽可能密集、题目本身要尽可能具备综合性，这样才能一箭双雕甚至一箭N雕，进而体现区分度、最大化面试过程的效率。</p> <p>能够同时在这两个方面占尽优势的考题其实并不是很多，“用栈实现队列”这样的问题算是其中的佼佼者：一方面，它考察的确实是数据结构中的经典内容；另一方面，它又覆盖了两个大的知识点、足以检验出候选人编码基本功的扎实程度。唯一的 BUG 可能就是深度和复杂度不够，换句话说就是不够难。</p> <p>这个特点，在普通算法面试中可能是 BUG，但在前端算法面试中，实在未必。大家要知道，你是前端，你的面试官也是前端，前端行业普遍的算法水平是啥样他心里还没个数吗...... 实际上大多数前端算法面试题的风格都是非常务实的，需要你炫技的实属特殊情况。</p> <h2 id="如何用栈实现一个队列"><a href="#如何用栈实现一个队列" class="header-anchor">#</a> 如何用栈实现一个队列？</h2> <p>题目描述：使用栈实现队列的下列操作：</p> <ul><li>push(x) -- 将一个元素放入队列的尾部。</li> <li>pop() -- 从队列首部移除元素。</li> <li>peek() -- 返回队列首部的元素。</li> <li>empty() -- 返回队列是否为空。</li></ul> <p>示例:</p> <ul><li>MyQueue queue = new MyQueue();</li> <li>queue.push(1);</li> <li>queue.push(2);</li> <li>queue.peek(); // 返回 1</li> <li>queue.pop(); // 返回 1</li> <li>queue.empty(); // 返回 false</li></ul> <p>说明:</p> <ul><li>你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</li> <li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li> <li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li></ul> <p><strong>思路分析</strong></p> <p>做这道题大家首先要在心里清楚一个事情：栈和队列的区别在哪里？</p> <p>仔细想想，栈，后进先出；队列，先进先出。也就是说两者的进出顺序其实是反过来的。用栈实现队列，说白了就是用栈实现先进先出的效果，再说直接点，就是想办法让栈底的元素首先被取出，也就是让出栈序列被逆序。</p> <p>乍一看有点头大：栈结构决定了栈底元素只能被死死地压在最底下，如何使它首先被取出呢？</p> <p>一个栈做不到的事情，我们用两个栈来做：</p> <p>首先，准备两个栈：</p> <p><img src="http://img-repo.poetries.top/images/20210905122814.png" alt=""></p> <p>现在问题是，怎么把第一个栈底下的那个 1 给撬出来。仔细想想，阻碍我们接触到 1 的是啥？是不是它头上的 3 和 2？那么如何让 3 和 2 给 1 让路呢？实际上咱们完全可以把这三个元素按顺序从 stack1 中出栈、然后入栈到 stack 2 里去：</p> <p><img src="http://img-repo.poetries.top/images/20210905122822.png" alt=""></p> <ul><li>此时 1 变得触手可及。不仅如此，下一次我们试图出队 2 的时候，可以继续直接对 stack2 执行出栈操作——因为转移 2 和 3 的时候已经做过一次逆序了，此时 stack2 的出栈序列刚好就对应队列的出队序列。</li> <li>有同学会问，那如果 stack1 里入栈新元素怎么办？比如这样：</li></ul> <p><img src="http://img-repo.poetries.top/images/20210905122830.png" alt=""></p> <blockquote><p>你会发现这个4按照顺序应该在 1、2、3 后出栈。当 4 需要被出栈时，stack2 一定已经空掉了。当 stack2 为空、而 stack1 不为空时，我们需要继续把 stack1 中的元素转移到 stack2 中去，然后再从 stack2 里取元素。也就是说，所有的出队操作都只能依赖 stack2 来完成——只要我们坚持这个原则，就可以确保 stack1 里的元素都能够按照正确的顺序（逆序）出栈。</p></blockquote> <p>我们按照这个思路来写代码：</p> <p>编码实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * 初始化构造函数
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">MyQueue</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 初始化两个栈</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stack1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stack2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/**
* Push element x to the back of queue.
* @param {number} x
* @return {void}
*/</span>
<span class="token class-name">MyQueue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">push</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 直接调度数组的 push 方法</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/**
* Removes the element from in front of queue and returns that element.
* @return {number}
*/</span>
<span class="token class-name">MyQueue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">pop</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 假如 stack2 为空，需要将 stack1 的元素转移进来</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当 stack1 不为空时，出栈</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>length <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 将 stack1 出栈的元素推入 stack2</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 为了达到逆序的目的，我们只从 stack2 里出栈元素</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/**
* Get the front element.
* @return {number}
* 这个方法和 pop 唯一的区别就是没有将定位到的值出栈
*/</span>
<span class="token class-name">MyQueue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">peek</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当 stack1 不为空时，出栈</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>length <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 将 stack1 出栈的元素推入 stack2</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 缓存 stack2 的长度</span>
  <span class="token keyword">const</span> stack2Len <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword">return</span> stack2Len <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">[</span>stack2Len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/**
* Returns whether the queue is empty.
* @return {boolean}
*/</span>
<span class="token class-name">MyQueue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">empty</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 若 stack1 和 stack2 均为空，那么队列空</span>
  <span class="token keyword">return</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="认识双端队列"><a href="#认识双端队列" class="header-anchor">#</a> 认识双端队列</h2> <blockquote><p>双端队列衍生出的滑动窗口问题，是一个经久不衰的命题热点。关于双端队列，各种各样的解释五花八门，这里大家不要纠结，就记住一句话：</p></blockquote> <p>双端队列就是允许在队列的两端进行插入和删除的队列。</p> <p>体现在编码上，最常见的载体是既允许使用 pop、push 同时又允许使用 shift、unshift 的数组：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token comment">// 定义一个双端队列   </span>
queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 双端队列尾部入队 </span>
queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 双端队列尾部出队   </span>
queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 双端队列头部出队 </span>
queue<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 双端队列头部入队</span>
</code></pre></div><p>现在相信你对双端队列已经形成了一个感性的认知，咱们紧接着就开始做题，在题里去认知这种结构的特征和效用。</p> <h2 id="滑动窗口问题"><a href="#滑动窗口问题" class="header-anchor">#</a> 滑动窗口问题</h2> <blockquote><p>题目描述：给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p></blockquote> <p>示例:</p> <blockquote><p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7]</p></blockquote> <p>解释: 滑动窗口的位置</p> <hr> <div class="language- extra-class"><pre class="language-text"><code>[1 3 -1] -3 5 3 6 7

1 [3 -1 -3] 5 3 6 7
1 3 [-1 -3 5] 3 6 7
1 3 -1 [-3 5 3] 6 7
1 3 -1 -3 [5 3 6] 7
1 3 -1 -3 5 [3 6 7]
</code></pre></div><p>最大值分别对应：</p> <div class="language- extra-class"><pre class="language-text"><code>3 3 5 5 6 7
</code></pre></div><p>提示：你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p> <p><strong>思路分析：双指针+遍历法</strong></p> <blockquote><p>这道题如果只是为了做对，那么思路其实不难想，我们直接模拟题中描述的这个过程就行。</p></blockquote> <p>按照题意，它要求我们在遍历数组的过程当中，约束一个窗口——窗口的本质其实就是一个范围，像这样：</p> <div class="language- extra-class"><pre class="language-text"><code>[1  3  -1] -3  5  3  6  7 
</code></pre></div><p>范围就被圈定在了前三个元素。</p> <p>我们前面学过，约束范围，可以用双指针。因此我这里定义一个 left 左指针、定义一个 right 右指针，分别指向窗口的两端即可：</p> <p><img src="http://img-repo.poetries.top/images/20210905122848.png" alt=""></p> <p>接下来我们可以把这个窗口里的数字取出来，直接遍历一遍、求出最大值，然后把最大值存进结果数组。这样第一个窗口的最大值就有了。</p> <p>接着按照题意，窗口每次前进一步（左右指针每次一起往前走一步），此时的范围变成了这样：</p> <p><img src="http://img-repo.poetries.top/images/20210905122855.png" alt=""></p> <p>我们要做的仍然是取出当前范围的所有元素、遍历一遍求出最大值，然后将最大值存进结果数组。</p> <p>反复执行上面这个过程，直到数组完全被滑动窗口遍历完毕，我们也就得到了问题的答案。</p> <p>基于这个淳朴的思路，我们来写一波代码：</p> <p>编码实现：双指针+遍历法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">maxSlidingWindow</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 缓存数组的长度</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token comment">// 定义结果数组</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 初始化左指针</span>
  <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">// 初始化右指针</span>
  <span class="token keyword">let</span> right <span class="token operator">=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token comment">// 当数组没有被遍历完时，执行循环体内的逻辑</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 计算当前窗口内的最大值</span>
    <span class="token keyword">const</span> max <span class="token operator">=</span> <span class="token function">calMax</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 将最大值推入结果数组</span>
    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 左指针前进一步</span>
    left<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment">// 右指针前进一步</span>
    right<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 返回结果数组</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 这个函数用来计算最大值</span>
<span class="token keyword">function</span> <span class="token function">calMax</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 处理数组为空的边界情况</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arr <span class="token operator">||</span> <span class="token operator">!</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 初始化 maxNum 的值为窗口内第一个元素</span>
  <span class="token keyword">let</span> maxNum <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 遍历窗口内所有元素，更新 maxNum 的值</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> maxNum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      maxNum <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 返回最大值</span>
  <span class="token keyword">return</span> maxNum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>解法复盘</strong></p> <p>上面这个解法，你在面试的时候写上去，完全没有问题，也不用担心超时。</p> <p>有的同学可能会觉得 calMax 这个函数多余了，认为可以直接用 Math.max 这个 JS 原生方法。其实就算是Math.max，也不可避免地需要对你传入的多个数字做最小值查找，calMax 和Math.max做的工作可以说是一样的辛苦。我这里手动实现一个 calMax， 大家会对查找过程造成的时间开销有更直观的感知。</p> <p>现在我们来思考一下，上面这一波操作下来，时间复杂度是多少？
这波操作里其实涉及了两层循环，外层循环是 while，它和滑动窗口前进的次数有关。滑动窗口前进了多少次，while 就执行了多少次。</p> <p>假设数组的规模是 n，那么从起始位置开始，滑动窗口每次走一步，一共可以走 n - k 次。注意别忘了初始位置也算作一步的，因此一共走了 n - k + 1次。然后每个窗口内部我们又会固定执行 k 次遍历。注意 k 可不是个常数，它和 n 一样是个变量。因此这个时间复杂度简化后用大 O 表示法可以记为 O(kn)。</p> <p>O(kn) 虽然不差，但对这道题来说，还不是最好。因此在面试过程中，如果你采用了上面这套解法做出了这个题，面试官有 99% 的可能性会追问你：这个题可以优化吗？如何优化？（或者直接问你，你能在线性时间复杂度内解决此题吗？）</p> <p>答案当然是能，然后面试官就会搬个小板凳坐你旁边，看看你怎么妙手回春，变 O(kn) 为 O(n)。</p> <p>接下来你需要表演的，正是面试官期待已久的双端队列解法啊！</p> <p><strong>思路分析：双端队列法</strong></p> <p>要想变 O(kn) 为 O(n)，我们就要想怎么做才能丢掉这个 k。</p> <p>k 之所以会产生，是因为我们现在只能通过遍历来更新最大值。那么更新最大值，有没有更高效的方法呢？</p> <p>大家仔细想想，当滑动窗口往后前进一步的时候，比如我从初始位置前进到第二个位置：</p> <p><img src="http://img-repo.poetries.top/images/20210905122906.png" alt=""></p> <p>（图中红色的范围是初始位置时，滑动窗口覆盖到的元素）</p> <blockquote><p>此时滑动窗口内的元素少了一个 1，增加了一个 -3——减少的数不是当前最大值，增加的数也没有超越当前最大值，因此最大值仍然是 3。此时我们不禁要想：如果我们能在窗口发生移动时，只根据发生变化的元素对最大值进行更新，那复杂度是不是就低很多了？</p></blockquote> <p>双端队列可以完美地帮助我们达到这个目的。</p> <p>使用双端队列法，核心的思路是维护一个有效的递减队列。</p> <p>在遍历数组的前期，我们尝试将遍历到的每一个元素都推入队列内部（下图是第一个元素入队的示意图）：</p> <p><img src="http://img-repo.poetries.top/images/20210905122914.png" alt=""></p> <blockquote><p>每尝试推入一个元素前，都把这个元素与队列尾部的元素作对比。根据对比结果的不同，采取不同的措施：</p></blockquote> <ul><li>如果试图推入的元素（当前元素）大于队尾元素，则意味着队列的递减趋势被打破了。此时我们需要将队列尾部的元素依次出队（注意由于是双端队列，所以队尾出队是没有问题的）、直到队尾元素大于等于当前元素为止，此时再将当前元素入队。</li> <li>如果试图推入的元素小于队列尾部的元素，那么就不需要额外的操作，直接把当前元素入队即可。</li></ul> <p>我用动画来表达一下这个过程：</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/171918a1ae330dd3~tplv-t2oaga2asx-watermark.awebp" alt=""></p> <p>维持递减队列的目的，就在于确保队头元素始终是当前窗口的最大值。</p> <blockquote><p>当遍历到的元素个数达到了 k 个时，意味着滑动窗口的第一个最大值已经产生了，我们把它 push 进结果数组里：</p></blockquote> <p><img src="http://img-repo.poetries.top/images/20210905122939.png" alt=""></p> <p>然后继续前进，我们发现数组索引 0 处的元素（1）已经被踢出滑动窗口了（图中红色方块对应的是当前滑动窗口覆盖到的元素们）：</p> <p><img src="http://img-repo.poetries.top/images/20210905122950.png" alt=""></p> <p>为了确保队列的有效性，需要及时地去队列检查下 1 这个元素在不在队列里（在的话要及时地踢出去，因为队列本身只维护当前滑动窗口内的元素）。</p> <blockquote><p>这里大家思考一下，我在查找 1 的时候，需不需要遍历整个队列？答案是不需要，因为 1 是最靠前的一个元素，如果它在，那么它一定是队头元素。这里我们只需要检查队头元素是不是 1 就行了。 此时我们检查队头，发现是 3：</p></blockquote> <p><img src="http://img-repo.poetries.top/images/20210905122957.png" alt=""></p> <p>没错，1早就因为不符合递减趋势被从队头干掉了。此时我们可以断定，当前双端队列里的元素都是滑动窗口已经覆盖的有效元素——没毛病，继续往下走就行了。</p> <blockquote><p>接下来，每往前遍历一个元素，都需要重复以上的几个步骤。这里我总结一下每一步都做了什么：</p></blockquote> <ul><li>检查队尾元素，看是不是都满足大于等于当前元素的条件。如果是的话，直接将当前元素入队。否则，将队尾元素逐个出队、直到队尾元素大于等于当前元素为止。</li> <li>将当前元素入队</li> <li>检查队头元素，看队头元素是否已经被排除在滑动窗口的范围之外了。如果是，则将队头元素出队。</li> <li>判断滑动窗口的状态：看当前遍历过的元素个数是否小于 k。如果元素个数小于k，这意味着第一个滑动窗口内的元素都还没遍历完、第一个最大值还没出现，此时我们还不能动结果数组，只能继续更新队列；如果元素个数大于等于k，这意味着滑动窗口的最大值已经出现了，此时每遍历到一个新元素（也就是滑动窗口每往前走一步）都要及时地往结果数组里添加当前滑动窗口对应的最大值（最大值就是此时此刻双端队列的队头元素）。</li></ul> <blockquote><p>这四个步骤分别有以下的目的：</p></blockquote> <ul><li>维持队列的递减性：确保队头元素是当前滑动窗口的最大值。这样我们每次取最大值时，直接取队头元素即可。</li> <li>这一步没啥好说的，就是在维持队列递减性的基础上、更新队列的内容。</li> <li>维持队列的有效性：确保队列里所有的元素都在滑动窗口圈定的范围以内。</li> <li>排除掉滑动窗口还没有初始化完成、第一个最大值还没有出现的特殊情况。</li></ul> <p>结合以上的分析，我们来写代码：</p> <p>编码实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">maxSlidingWindow</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 缓存数组的长度</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token comment">// 初始化结果数组</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 初始化双端队列</span>
  <span class="token keyword">const</span> deque <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 开始遍历数组</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当队尾元素小于当前元素时</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>deque<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>deque<span class="token punctuation">[</span>deque<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 将队尾元素（索引）不断出队，直至队尾元素大于等于当前元素</span>
      deque<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 入队当前元素索引（注意是索引）</span>
    deque<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 当队头元素的索引已经被排除在滑动窗口之外时</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>deque<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> deque<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> i <span class="token operator">-</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 将队头元素索引出队</span>
      deque<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 判断滑动窗口的状态，只有在被遍历的元素个数大于 k 的时候，才更新结果数组</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>deque<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 返回结果数组</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></div> <!----> <div class="readMore-wrapper"><span class="readMore">阅读全文</span></div></div> <div class="right-bar"><img src="http://img-repo.poetries.top/images/20211218210701.png" class="close"> <div class="item"><span class="title">前端进阶公众号</span> <span class="desc">每天分享前端干货文章</span> <img width="100%" alt="公众号「前端进阶之旅」" src="http://img-repo.poetries.top/images/20211001080240.png"></div> <!----></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/FE-Interview-Questions/algorithm-interview/note/11-栈与队列怎么玩（上）.html" class="prev">栈与队列怎么玩（上）</a></span> <span class="next"><a href="/FE-Interview-Questions/algorithm-interview/note/13-遍历专题 DFS 与 BFS.html">遍历专题 DFS 与 BFS</a>
      →
    </span></p></div>  <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="注册会员账号" class="el-dialog el-dialog--center" style="margin-top:15vh;width:32%;"><div class="el-dialog__header"><span class="el-dialog__title">注册会员账号</span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><div class="el-dialog__footer"><span class="dialog-footer"><!----> <!----> <button type="button" class="el-button el-button--danger" style="width:100%;"><!----><!----><span>我已完成支付？下一步，去注册</span></button></span></div></div></div> <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="微信扫码登录" class="el-dialog el-dialog--center" style="margin-top:15vh;width:30%;"><div class="el-dialog__header"><span class="el-dialog__title">微信扫码登录</span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><!----></div></div> <img src="data:image/png;base64,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" class="theme-float-btn"> <div class="el-dialog__wrapper" style="display:none;"><div role="dialog" aria-modal="true" aria-label="站点迁移通知" class="el-dialog el-dialog--center" style="margin-top:15vh;width:30%;"><div class="el-dialog__header"><span class="el-dialog__title">站点迁移通知</span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><!----></div></div></main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/FE-Interview-Questions/assets/js/app.4d3eef8b.js" defer></script><script src="/FE-Interview-Questions/assets/js/5.d87f3d46.js" defer></script><script src="/FE-Interview-Questions/assets/js/4.5e30d557.js" defer></script><script src="/FE-Interview-Questions/assets/js/27.2e5ff387.js" defer></script><script src="/FE-Interview-Questions/assets/js/11.7002e677.js" defer></script>
  </body>
</html>
